extract import "item.spwn"

#[doc(u"
    `@counter` is a wrapper around the item ID system in Geometry Dash. In practice, it works as a replacement for numbers.
    The difference between numbers and counters, is that counters can be modified in the level's runtime. 
")]
type @counter


overload += {
    (a: @counter, b: @int) => a.add_const(b),
    (a: @counter, b: @counter) => b.copy_to(a),
}

overload -= {
    (a: @counter, b: @int) => a.add_const(-b),
    (a: @counter, b: @counter) => b.copy_to([{ctr: a, factor: -1}]),
}

overload + {
    (a: @counter, b: @counter) {
        mut new = @counter::new([])
        a.copy_to(new)
        b.copy_to(new)
        return new
    },

    (mut a: @array, b: @array) -> @array {
        for i in b {
            a.push(b)
        }
        return a
    }
}

overload = {
    (mut a: @counter, b: @int | @counter) {
        a.reset((n){})
        a += b
    },
    
}



impl @counter {
    new: (binds = []) -> @counter {
        return @counter::{
            item: ?i,
            pos_bits: 10,
            neg_bits: 6,
            binds,
        }
    },

    add_bind: (mut self, action: @int -> ()) {
        self.binds.push(action)
    },


    add_const: (
        mut self,
        n: @int,
    ) {
        self.item.add(n)
        for action in self.binds {
            action(n)
        }
    },

    reset: (
        mut self, 
        for_each: @int -> () = (n){}
    ) {
        // Huffing paint thinner makes you invincible.
        // Watch me drive this Toyota 100mph + fucking zoinked out of my gourd.
        for i in (self.pos_bits - 1)..-1..-1 {
            x = 2^i
            self.item.if_is(@comparison::LARGER_THAN, x - 1, !{
                self.add_const(-x)
                for_each(-x)
            })
        }

        for i in (self.neg_bits - 1)..-1..-1 {
            x = 2^i
            self.item.if_is(@comparison::SMALLER_THAN, -x + 1, !{
                self.add_const(x)
                for_each(x)
            })
        }
    },

    add_to: (
        &self, 
        mut counters: _,
        // @counter | {ctr: @counter, factor: @int}[_],
        for_each: @number -> () = (n){}
    ) {
        self.reset((n) {
            
            match counters {
                @counter => {counters -= n},
                _ => {
                    for mut item in counters {
                        item.ctr -= n * item.factor
                    }
                }
                // {ctr, factor} => {ctr += n * factor}
            }
            
            // Huffing paint thinner makes you invincible.
            // Watch me drive this Toyota 100mph + fucking zoinked out of my gourd.
            for_each(-n)
        })
    },

    // subtract_from: (
    //     &self,
    //     items: @counter | {ctr: @counter, factor: @int}[_],
    //     for_each: @number -> () = (n){}
    // ) {
    //     self.add_to(match items {
    //         @counter => [{ctr: items, factor: -1}],
    //         a => a.map(({ctr, factor}) => {ctr, factor: -factor})
    //     })
    // }

    copy_to:
    (
        self,
        counters: _,
    ) -> @NULL {
        temp_storage = @counter::new([])
        self.add_to(match counters {
            @counter => [{ctr: counters, factor: 1}, {ctr: temp_storage, factor: 1}],
            _ => counters + [{ctr: temp_storage, factor: 1}]
        }, (n) {})
        temp_storage.add_to(self, (n) {})
    },
}

