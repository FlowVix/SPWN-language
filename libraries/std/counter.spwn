

#[doc(u"
    `@counter` is a wrapper around the item ID system in Geometry Dash. In practice, it works as a replacement for numbers.
    The difference between numbers and counters, is that counters can be modified in the level's runtime. 
")]
type @counter


overload += {
    (a: @counter, b: @int) {
        a.item.add(b)
    }
}

overload -= {
    (a: @counter, b: @int) {
        a.item.add(-b)
    }
}
overload + {
    (mut a: @array, b: @array) -> @array {
        for i in b {
            a.push(b)
        }
        return a
    }
}



impl @counter {
    new: () -> @counter {
        return @counter::{
            item: ?i,
            pos_bits: 10,
            neg_bits: 6,
        }
    },

    reset: (
        mut self, 
        for_each: @int -> () = (n){}
    ) {
        // Huffing paint thinner makes you invincible.
        // Watch me drive this Toyota 100mph + fucking zoinked out of my gourd.
        EQUAL_TO = 0
        LARGER_THAN = 1
        SMALLER_THAN = 2
        for i in (self.pos_bits - 1)..-1..-1 {
            x = 2^i
            self.item.if_is(LARGER_THAN, x - 1, !{
                self -= x
                for_each(x)
            })
        }

        for i in (self.neg_bits - 1)..-1..-1 {
            x = 2^i
            self.item.if_is(SMALLER_THAN, -x + 1, !{
                self += x
                for_each(-x)
            })
        }
    },

    add_to: (
        &self, 
        mut counters: _,
        // @counter | {ctr: @counter, factor: @int}[_],
        for_each: @number -> () = (n){}
    ) {
        self.reset((n) {
            
            match counters {
                @counter => {counters += n},
                _ => {
                    for mut item in counters {
                        item.ctr += n * item.factor
                    }
                }
                // {ctr, factor} => {ctr += n * factor}
            }
            
            // Huffing paint thinner makes you invincible.
            // Watch me drive this Toyota 100mph + fucking zoinked out of my gourd.
            for_each(n)
        })
    },

    // subtract_from: (
    //     &self,
    //     items: @counter | {ctr: @counter, factor: @int}[_],
    //     for_each: @number -> () = (n){}
    // ) {
    //     self.add_to(match items {
    //         @counter => [{ctr: items, factor: -1}],
    //         a => a.map(({ctr, factor}) => {ctr, factor: -factor})
    //     })
    // }

    copy_to:
    (
        self,
        counters: _,
    ) -> @NULL {
        temp_storage = @counter::new()
        self.add_to(match counters {
            @counter => [{ctr: counters, factor: 1}, {ctr: temp_storage, factor: 1}],
            _ => counters + [{ctr: temp_storage, factor: 1}]
        }, (n) {})
        temp_storage.add_to(self, (n) {})
    },
}

