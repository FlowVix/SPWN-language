extract import "item.spwn"
extract import "obj_ids.spwn"

impl @int {
    max: (self, v) {
        if self > v {
            return self
        }
        return v
    }
}

#[doc(u"
    `@counter` is a wrapper around the item ID system in Geometry Dash. In practice, it works as a replacement for numbers.
    The difference between numbers and counters, is that counters can be modified in the level's runtime.

    # Example
    ```spwn
    left = counter(9)
    right = counter(10)

    if left + right >= 21 {
        10g.move(10, 0, 0.5)
    } else {
        10g.move(-10, 0, 0.5)
    }
    ```
")]
type @counter

overload += {
    (a: @counter, b: @int) => a.add_const(b),
    (a: @counter, b: @counter) => b.copy_to(a),
}

overload *= {
    (a: @counter, b: @int | @counter) => a.multiply(b),
}

overload -= {
    (a: @counter, b: @int) => a.add_const(-b),
    (a: @counter, b: @counter) => b.copy_to([{ctr: a, factor: -1}]),
}

compare_int_counter = (ret_false_func, ret_true_func) {
    ret_false = !{
        -> return false
    }
    ret_true_func(!{
        ret_false.start_group.toggle_off()
        -> return true
    })
    ret_false_func(ret_false)
    ret_false.start_group.toggle_on()
}

overload == {
    (a: @counter, b: @counter) => a.compare(b) == 0,
    (a: @counter, b: @int) => compare_int_counter(
        (ret_false) {
            a.item.if_is(@comparison::LARGER_THAN, b, ret_false)
            a.item.if_is(@comparison::SMALLER_THAN, b, ret_false)
        },
        ret_true => a.item.if_is(@comparison::EQUAL_TO, b, ret_true)
    ),
    (a: @int, b: @counter) => compare_int_counter(
        (ret_false) {
            b.item.if_is(@comparison::LARGER_THAN, a, ret_false)
            b.item.if_is(@comparison::SMALLER_THAN, a, ret_false)
        },
        ret_true => b.item.if_is(@comparison::EQUAL_TO, a, ret_true)
    ),
}

overload != {
    (a: @counter, b: @counter) => !(a == b),
    (a: @counter, b: @int) => !(a == b),
    (a: @int, b: @counter) => !(a == b),
}

overload > {
    (a: @counter, b: @counter) => a.compare(b) == 1,
    (a: @counter, b: @int) => compare_int_counter(
        ret_false => a.item.if_is(@comparison::SMALLER_THAN, b + 1, ret_false),
        ret_true => a.item.if_is(@comparison::LARGER_THAN, b, ret_true)
    ),
    (a: @int, b: @counter) => compare_int_counter(
        ret_false => b.item.if_is(@comparison::LARGER_THAN, a - 1, ret_false),
        ret_true => b.item.if_is(@comparison::SMALLER_THAN, a, ret_true)
    )
}

overload < {
    (a: @counter, b: @counter) => a.compare(b) == -1,
    (a: @counter, b: @int) => compare_int_counter(
        ret_false => a.item.if_is(@comparison::LARGER_THAN, b - 1, ret_false),
        ret_true => a.item.if_is(@comparison::SMALLER_THAN, b, ret_true)
    ),
    (a: @int, b: @counter) => compare_int_counter(
        ret_false => b.item.if_is(@comparison::SMALLER_THAN, a + 1, ret_false),
        ret_true => b.item.if_is(@comparison::LARGER_THAN, a, ret_true)
    )
}

overload >= {
    (a: @counter, b: @counter) => a.compare(b) >= 0,
    (a: @counter, b: @int) => compare_int_counter(
        ret_false => a.item.if_is(@comparison::SMALLER_THAN, b, ret_false),
        ret_true => a.item.if_is(@comparison::LARGER_THAN, b - 1, ret_true)
    ),
    (a: @int, b: @counter) => compare_int_counter(
        ret_false => b.item.if_is(@comparison::LARGER_THAN, a, ret_false),
        ret_true => b.item.if_is(@comparison::SMALLER_THAN, a + 1, ret_true)
    ),
}

overload <= {
    (a: @counter, b: @counter) => a.compare(b) <= 0,
    (a: @counter, b: @int) => compare_int_counter(
        ret_false => a.item.if_is(@comparison::LARGER_THAN, b, ret_false),
        ret_true => a.item.if_is(@comparison::SMALLER_THAN, b + 1, ret_true)
    ),
    (a: @int, b: @counter) => compare_int_counter(
        ret_false => b.item.if_is(@comparison::SMALLER_THAN, a, ret_false),
        ret_true => b.item.if_is(@comparison::LARGER_THAN, a - 1, ret_true)
    )
}


compound_counter = (counters: @counter[_], reset: @bool = true, value: @int = 0) {
    mut max_pos_bits = 0
    mut max_neg_bits = 0
    for counter in counters {
        max_pos_bits = max_pos_bits.max(counter.pos_bits)
        max_neg_bits = max_neg_bits.max(counter.neg_bits)
    }
    return @counter::new(
        value,
        bits = max_pos_bits, 
        neg_bits = max_neg_bits, 
        reset = reset
    )
}

overload + {
    (a: @counter, b: @counter) {
        new = compound_counter([a, b]);
        a.copy_to(new);
        b.copy_to(new);
        return new
    },

    (a: @int, b: @counter) {
        new = compound_counter([b], value = a);
        b.copy_to(new);
        return new
    },

    (a: @counter, b: @int) {
        new = compound_counter([a], value = b);
        a.copy_to(new);
        return new
    },

    (mut a: @array, b: @array) -> @array {
        for i in b {
            a.push(i)
        }
        return a
    }
}

overload = {
    (mut a: @counter, b: @int | @counter) {
        a.reset()
        a += b
    },
    
}



impl @counter {
    new: (
        initial: @int | @item = 0, 
        reset: @bool = true, 
        bits: @int & >=0 = 10, 
        neg_bits: @int & >=0 = 0
    ) -> @counter {
        item = match initial {
            @item => initial,
            _ => ?i
        }
        out = @counter::{
            item,
            pos_bits: bits,
            neg_bits: neg_bits,
            binds: [],
        }
        if reset {
            out.reset()
        }
        if initial is @int {
            item.add(initial)
        }
        return out
    },

    add_bind: (mut self, action: @int -> ()) {
        self.binds.push(action)
    },


    add_const: (
        mut self,
        n: @int,
    ) {
        self.item.add(n)
        for action in self.binds {
            action(n)
        }
    },

    display: (&self, x: @int | @float, y: @int | @float) {
        $.add(obj {
            OBJ_ID: @obj_id::misc.ITEM_DISPLAY,
            X: x,
            Y: y,
            ITEM: self.item,
            COLOR: 1c,
            GROUPS: 999g
        })
    },

    to_obj: (&self) -> @object {
        return obj {
            OBJ_ID: @obj_id::misc.ITEM_DISPLAY,
            ITEM: self.item,
            COLOR: 1c,
            GROUPS: 999g
        }
    },

    reset: (
        mut self, 
        for_each: @int -> () = (n){}
    ) {
        // Huffing paint thinner makes you invincible.
        // Watch me drive this Toyota 100mph + fucking zoinked out of my gourd.
        for i in (self.pos_bits - 1)..-1..-1 {
            x = 2^i
            self.item.if_is(@comparison::LARGER_THAN, x - 1, !{
                self.add_const(-x)
                for_each(x)
            })
        }

        for i in (self.neg_bits - 1)..-1..-1 {
            x = 2^i
            self.item.if_is(@comparison::SMALLER_THAN, -x + 1, !{
                self.add_const(x)
                for_each(-x)
            })
        }
    },

    add_to: (
        &self, 
        mut counters: @counter | ({ctr: @counter, factor: @int}[_]),
        for_each: @int -> () = (n){}
    ) {
        self.reset((n) {
            match counters {
                @counter => {counters += n},
                _ => counters.map((mut item) {item.ctr += n * item.factor})
            }    
            for_each(-n)
        })
    },

    subtract_from: (
        &self,
        counters: @counter | ({ctr: @counter, factor: @int}[_]),
        for_each: @int -> () = (n){}
    ) {
        self.add_to(match counters {
            @counter => [{ctr: counters, factor: -1}],
            a => a.map(({ctr, factor}) => {ctr, factor: -factor})
        })
    },

    copy_to: (
        self,
        counters: @counter | ({ctr: @counter, factor: @int}[_]),
    ) {
        temp_storage = compound_counter([self], reset = false)
        
        self.add_to(match counters {
            @counter => [{ctr: counters, factor: 1}, {ctr: temp_storage, factor: 1}],
            _ => counters + [{ctr: temp_storage, factor: 1}]
        })
        
        temp_storage.add_to(self)
    },

    multiply: (self, factor: @counter | @int) {
        match factor {
            @int => {
                temp = compound_counter([self], reset = false)
                self.add_to([{ctr: temp, factor}])
                temp.add_to(self)
            },
            @counter => {
                result = compound_counter([self], reset = false)
                self.reset((n) {
                    factor.copy_to([{ctr: result, factor: n}])
                })
                result.add_to(self)
            }
        }
    },

    compare: (self, other: @counter) -> ==(-1) | ==0 | ==1 {
        mut comp = compound_counter([self, other])
        comp += self
        comp -= other

        comp.item.if_is(@comparison::LARGER_THAN, 0, !{
            -> return 1
        })

        comp.item.if_is(@comparison::EQUAL_TO, 0, !{
            -> return 0
        })

        comp.item.if_is(@comparison::SMALLER_THAN, 0, !{
            -> return -1
        })
    },

    to_const: (self, range: @int[_] | @range) -> @int {
        mut funcs = []

        for val in range {
            funcs.push([val, !{
                -> return val
            }])
        }

        for val in range {
            self.item.if_is(@comparison::EQUAL_TO, val, !{
                for [val2, func] in funcs {
                    if val2 != val {
                        func.start_group.toggle_off()
                    } else {
                        func!
                    }
                }
            })
        }

        for func in funcs {
            func[1].start_group.toggle_on()
        }
    },

    to_const_enclosed: (
        self,
        range: @int[_] | @range,
        closure: @int -> (),
    ) {
        -> () {
            val = self.to_const(range)
            closure(val)
        } ()
    },

	// #[doc(u"
	// 	Divides the value of the counter by some divisor

	// 	# Example
	// 	```spwn
    //     c = counter(7)
    //     r = counter(0)
    //     wait(1)

    //     c.divide(2, remainder = r)
    //     // c is now 3, r is now 1
    // 	```
	// ")]
    // divide: (
    //     self,
    //     divisor: @counter | @int,
    //     remainder: @counter | @item = ?i,
    // ) {
    //     result = @counter::new(0, reset = false, bits = self.bits)
    //     for i in self.bits..0 {
    //         num = 2^i
    //         if divisor is @number {
    //             -> if self >= divisor * num {
    //                 self.add(-divisor * num)
    //                 result.add(num)
    //             }
    //         } else if divisor is @counter {
    //             divisor.copy_to(self, factor = -num)
    //             result.add(num)
    //             -> if self < 0 {
    //                 divisor.copy_to(self, factor = num)
    //                 result.add(-num)
    //             }
    //         }
    //     }
    //     self.add_to(remainder)
    //     result.add_to(self)
    // },
}

